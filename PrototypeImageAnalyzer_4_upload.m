%%
%This program takes image file sets generated by the Harborview Trauma study code and
%segments and analyzes them. It does so with the low zoom setup Dec 2015
clear all;
clc;
warning('off','MATLAB:xlswrite:AddSheet');
%Find all the images in a folder and ignore missing numbers if there are errors
experiment_directory = uigetdir('*','Select the folder containing images'); %Ask for the folder to look into
%Load in the images

%%
image_props_structure = dir(fullfile(experiment_directory,'*.tif'));
image_names_unsorted = {image_props_structure.name}';
%Sort the names into the right order
disp(image_names_unsorted(1:5));
image_strings = regexp([image_names_unsorted{:}],'(\d*)','match');
image_numbers = str2double(image_strings);
[~,sorted_indices] = sort(image_numbers);
image_names_sorted = image_names_unsorted(sorted_indices);
disp(image_names_sorted(1:5));
disp('Images Sorted Correctly');
%%
%Create a matrix to store distance values into that matches order of image
%sequence. Create an indexer for the loop called 'framecounter'
prompt = {'What frame should it start from?'};
dlg_title = 'Frame Start';
num_lines = 1;
def = {'2'};
frame_start = inputdlg(prompt,dlg_title,num_lines,def);
frame_start = str2double(frame_start);

%Display the beginning image and show it
clf
current_frame = frame_start;
b = uicontrol('Parent',figure(1),'Style','slider','Position',[50,10,300,30],...
    'value',current_frame, 'min',1, 'max',numel(sorted_indices));
imshow(fullfile(experiment_directory,sprintf('img%d.tif',current_frame)));
set(gcf,'units','normalized','outerposition',[0.2 0.05 .6 .9]);
%Set the slider to refresh the window when the slider is moved
%%
%Generate an ROI on the image
% ROI_rect = imrect;
% position = wait(ROI_rect);

right_pairs = 'n';

while right_pairs == 'n';
    
    title('Click on each POST for analysis');
    [roi_x,roi_y,button] = ginput; % Ask the user to click on each of the good posts
    roi_x = floor(roi_x); %round ginputs to nearest integers
    roi_y = floor(roi_y); %round ginputs to nearest integers
    
    %Create box coordinates that are centered on the user click coordinates
    box_w = 80;                                                             %High Zoom: 120  ,  Low Zoom: 80 
    box_h = 180;                                                             %High Zoom: 240  ,  Low Zoom: 180
    
    roi_x(:,2) = roi_x(:,1) - floor(box_w/2);
    roi_y(:,2) = roi_y(:,1) + floor(box_h/2*2/3);
    roi_x(:,3) = roi_x(:,1) + floor(box_w/2);
    roi_y(:,3) = roi_y(:,1) + floor(box_h/2*2/3);
    roi_x(:,4) = roi_x(:,1) + floor(box_w/2);
    roi_y(:,4) = roi_y(:,1) - floor(box_h/2*4/3);
    roi_x(:,5) = roi_x(:,1) - floor(box_w/2);
    roi_y(:,5) = roi_y(:,1) - floor(box_h/2*4/3);
    
    roi_n = numel(button);
    roi_counter = 1;
    
    starting_image = imread(fullfile(experiment_directory,sprintf('img%d.tif',current_frame))); %Load in the beginning image
    image_size = size(starting_image);
    
    %Generate zero matrix that is going to be the image size, make it roi_n
    %layers deep
    roi = zeros(image_size(1), image_size(2), roi_n);
    
    while roi_counter <= roi_n
        rectangle('Position',[roi_x(roi_counter,5) roi_y(roi_counter,5) box_w box_h], 'LineWidth',2, 'EdgeColor','b');
        %Create individual masks out the ROIs for each of the objects. Each z-dimension is a seperate sensor
        %Set the regions within each ROI to 1 if it falls within the boundary
        %box
        roi([roi_y(roi_counter,5):roi_y(roi_counter,2)],roi_x(roi_counter,2):roi_x(roi_counter,3),roi_counter)=1;
        roi_counter = roi_counter+1;
    end
    
    roi = uint16(roi); %convert roi to unit8 or uint16 so that it can be multiplied later on
    
    prompt2 = {'These Legit? (1=y/0=n?)'};                     %This prompt stops the total loop by setting threshexample to
    dlg_title2 = 'Pairs Check';
    num_lines2 = 1;
    def2 = {'0'};
    pair_confirm = inputdlg(prompt2,dlg_title2,num_lines2,def2);
    pair_confirm = str2double(pair_confirm(1));
    
    if pair_confirm == 1;
        right_pairs = 'y';
    else
        right_pairs = 'n';
    end
end

%%
tic;
%make an array full of zeroes to store each 'page' of the crops to. The 4th
%dimension is time
dataarray = zeros(box_h+1, box_w+1, roi_n, size(image_names_sorted,1)); %This snags if the data_array and the TEST_cropped variables are mismatched in dimension.

%Use the masks made in the while loop in the above section to mask out
%image segments
%Go through each dimension of the image file and crop it
h = waitbar(0,'Seperating ROIs from Images');
steps_imageloading = numel(image_names_sorted);
counter_current_time = 1;

while counter_current_time <= size(image_names_sorted,1)
    %Read in an image
    TEST_image = imread(fullfile(experiment_directory,sprintf('img%d.tif',counter_current_time)));
    counter_current_crop = 1;
    while counter_current_crop <= roi_n
        TEST_cropped = TEST_image(:,:,1);
        TEST_cropped = TEST_cropped.*roi(:,:,counter_current_crop); %NOTE: Can remove the (:,:,1) from first if image is not RGB saved
        TEST_cropped(~roi(:,:,counter_current_crop)) = 0; %sets everything outside of the roi masks to zero for the image
        TEST_cropped(~any(TEST_cropped,2),:) = []; %Removes all rows that have zeros
        TEST_cropped(:,~any(TEST_cropped,1)) = []; %Removes all columns that have zeros NOTE: This is ok because real images won't be 0 value darkness even in background
        dataarray(:,:,counter_current_crop,counter_current_time) = TEST_cropped;
        counter_current_crop = counter_current_crop +1;
    end
    counter_current_time = counter_current_time + 1;
    disp(sprintf('Analyzed %d',counter_current_time));
    waitbar(counter_current_time / steps_imageloading);
end
close(h)
%NOTE: If dataarray has zeros eliminated to shrink matrix, it will mismatch
%the ROI array on the second loop
time_splitting = toc;
%%
%THIS SECTION SHOULD SHOW EXAMPLE IMAGES FOR EACH TIMEPOINT 0 25 50 75 100%
%AND SHOW WHAT THE OUTLINE LOOKS LIKE!!!

%In dataarray, X,Y of matrix is 1st and 2nd dimension
%Post number is 3rd dimension
%Time is 4th dimension

threshexample = 'y';

frame_total = numel(image_numbers);
frame_analyzed = frame_total - frame_start;
frame_25 = floor(frame_analyzed*0.25 + frame_start);
frame_50 = floor(frame_analyzed*0.50 + frame_start);
frame_75 = floor(frame_analyzed*0.75 + frame_start);

pre_current_data_array = zeros(box_h+1, box_w+1, roi_n, 5);

if threshexample == 'y';
    
    counter_ex_sub = 1;
    while counter_ex_sub <= roi_n;
        pre_current_data_array(:,:,counter_ex_sub,1) = dataarray(:,:,counter_ex_sub,frame_start);
        pre_current_data_array(:,:,counter_ex_sub,2) = dataarray(:,:,counter_ex_sub,frame_25);
        pre_current_data_array(:,:,counter_ex_sub,3) = dataarray(:,:,counter_ex_sub,frame_50);
        pre_current_data_array(:,:,counter_ex_sub,4) = dataarray(:,:,counter_ex_sub,frame_75);
        pre_current_data_array(:,:,counter_ex_sub,5) = dataarray(:,:,counter_ex_sub,frame_total);
        counter_ex_sub = counter_ex_sub + 1;
    end
end
%%
%This section steps through and does the analysis on 5 sample frames using
%the set threshold value then

clear ex_binary_I_final;
ex_binary_I_final = zeros(box_h+1,box_w+1,roi_n,5);
threshexample = 'y';

while threshexample == 'y';
    
    threshexample = 'y';
    if threshexample == 'y';                                                %Open up prompt to select initial threshold value for each post individually
        prompt = {'Starting Contrast Threshold Value'};
        dlg_title = 'Image Thresholding';
        num_lines = 1;
        def = {'23000'};
        contrast_thresh_value = str2double(inputdlg(prompt,dlg_title,num_lines,def)); %inputdlg outputs as a cell, so convert to a double value
    end
    
    if threshexample == 'y';
        counter_ex_5 = 1;
        while counter_ex_5 <= 5;
            ex_roi_counter = 1;
            while ex_roi_counter <= roi_n
                ex_current_data = pre_current_data_array;                          %Start operating on image processing of first ROI
                %ex_current_data_2d = ex_current_data(:,:,ex_roi_counter,counter_ex_5);
                ex_current_data_binary = ex_current_data(:,:,ex_roi_counter,counter_ex_5) > contrast_thresh_value;                 %create binary image to act as a mask for regionprops function
                
                ex_current_data_binary = imfill(imfill(imfill(ex_current_data_binary, 'holes'),'holes'),'holes');                      %Remove holes
                ex_current_data_binary = bwmorph(bwmorph(ex_current_data_binary,'clean'),'clean');                    %Get rid of isolated pixels. bwmorph has to be 2-d not 4-d
                ex_seD = strel('diamond',2);
                ex_current_data_binary = imerode(ex_current_data_binary,ex_seD);                    %Erode once, not twice in this step
                
                %ex_BWfinal = imerode(ex_BWfinal,ex_seD);
                ex_binary_I_final(:,:,ex_roi_counter,counter_ex_5) = ex_current_data_binary;        %Fix something here
                ex_roi_counter = ex_roi_counter + 1;
            end
            counter_ex_5 = counter_ex_5 + 1;
        end
    end
    
    %This section is for displaying the actual selected pictures
    
    graph_split = 1/roi_n;
    screensizz = get(0,'ScreenSize');
    figure('Position',[screensizz(3)/10 screensizz(4)/12 screensizz(3)/1.2 screensizz(4)/1.2])
    
    if threshexample == 'y';
        counter_ex_graph2 = 1;
        while counter_ex_graph2 <= roi_n;
%             subplot(roi_n,5,1 + counter_ex_graph1)
%             imshow(ex_binary_I_final(:,:,counter_ex_graph2,1)), title('t=0% Image');                      %Blank space should be filenames 1-5
%             subplot(roi_n,5,2 + counter_ex_graph1)
%             imshow(ex_binary_I_final(:,:,counter_ex_graph2,2)), title('t=25% Image');
%             subplot(roi_n,5,3 + counter_ex_graph1)
%             imshow(ex_binary_I_final(:,:,counter_ex_graph2,3)), title('t=50% Image');
%             subplot(roi_n,5,4 + counter_ex_graph1)
%             imshow(ex_binary_I_final(:,:,counter_ex_graph2,4)), title('t=75% Image');
%             subplot(roi_n,5,5 + counter_ex_graph1)
%             imshow(ex_binary_I_final(:,:,counter_ex_graph2,5)), title('t=100% Image');
%             counter_ex_graph2 = counter_ex_graph2 + 1;
%             counter_ex_graph1 = counter_ex_graph1 + 5;
            
            subplot(5,roi_n,counter_ex_graph2)
            imshow(ex_binary_I_final(:,:,counter_ex_graph2,1)), title('Start');                      %Blank space should be filenames 1-5
            subplot(5,roi_n,counter_ex_graph2+roi_n)
            imshow(ex_binary_I_final(:,:,counter_ex_graph2,2)), title('t=25% Image');
            subplot(5,roi_n,counter_ex_graph2+2*roi_n)
            imshow(ex_binary_I_final(:,:,counter_ex_graph2,3)), title('t=50% Image');
            subplot(5,roi_n,counter_ex_graph2+3*roi_n)
            imshow(ex_binary_I_final(:,:,counter_ex_graph2,4)), title('t=75% Image');
            subplot(5,roi_n,counter_ex_graph2+4*roi_n)
            imshow(ex_binary_I_final(:,:,counter_ex_graph2,5)), title('t=100% Image');
            counter_ex_graph2 = counter_ex_graph2 + 1;
        end
    end
    
    prompt = {'Does Outline Match Shapes? (1=y/0=n?)'};                     %This prompt stops the total loop by setting threshexample to
    dlg_title = 'Image Thresholding';
    num_lines = 1;
    def = {'0'};
    answerDoneThresh = inputdlg(prompt,dlg_title,num_lines,def);
    threshconfirmation = str2double(answerDoneThresh(1));
    
    if threshconfirmation == 1;
        threshexample = 'n';
    else threshconfirmation = 0;
        threshexample = 'y';
    end
    close all;
end
%imshow(fullfile(experiment_directory,sprintf('img%d.tif',current_frame)));

clear ex_binary_I_final ex_current_data ex_roi_counter;                     %Remove example space variables
%%
%X,Y of matrix is 1st and 2nd dimension, Post number is 3rd dimension, Time
%is 4th dimension, in the datarack storage array, there should only be 1
%coordinate entered per post, 3rd dimension is the post number

%make storage matrices full of zeroes that has number of elements equal to number
%of total images minus the starting frame number
area_block_min = 700;                                                      %For High Zoom: 2000 , Low Zoom: 700
area_block_min_edge = 500;                                                 %For High Zoom: 1600 , Low Zoom: 500
area_block_max = 2000;                                                      %For High Zoom: 2700, Low Zoom: 2000
area_block_max_edge = 2400;                                                 %For High Zoom: 3000, Low Zoom: 2400
area_post_min = 50;                                                         %For High Zoom: 50  , Low Zoom: 50
area_post_max = 225;                                                        %For High Zoom: 250 , Low Zoom: 225
loop_thresh = 'y';

arearack = zeros(numel(image_names_sorted)-frame_start,2,roi_n);             %Area rack 1st number is block area, 2nd is post area, 3rd dimension is post number
datarack_blocks = zeros(numel(image_names_sorted)-frame_start,2,roi_n);
datarack_posts = zeros(numel(image_names_sorted)-frame_start,2,roi_n);
datarack_contrast_thresh = zeros(numel(image_names_sorted)-frame_start,1,roi_n);
datarack_brightness = zeros(numel(image_names_sorted)-frame_start,1,roi_n);  %This matrix stores brightness matrixes
%%
tic;
h2 = waitbar(0,'Processing Images');
steps_threshholding = numel(image_names_sorted)-frame_start;
counter_analysistime = frame_start;
while counter_analysistime <= numel(image_names_sorted)
    counter_analysissensor = 1;
    while counter_analysissensor <= roi_n
        current_data = dataarray(:,:,counter_analysissensor,counter_analysistime); %Start operating on image processing of first ROI
        start_contrast_thresh = contrast_thresh_value;
        datarack_brightness(counter_analysistime,1,counter_analysissensor) = mean(mean(current_data(:,:)));    %Compute the mean value of the entire current_data array
        loop_thresh = 'y';
        counter_breaker = 1;
        while counter_breaker <= 20;
            if loop_thresh == 'y';
                
                binary_mask = current_data > start_contrast_thresh;                    %create binary image to act as a mask for regionprops function
                binary_mask = imfill(imfill(imfill(binary_mask, 'holes'),'holes'),'holes'); %Remove holes 3x
                binary_mask = bwmorph(binary_mask,'clean');                              %Get rid of isolated pixels, 2x
                
                seD = strel('diamond',2);
                binary_mask = imerode(binary_mask,seD);
                
                %%%%%%%%%%%%%%%%%%%%%%%%%
                current_areas = regionprops(binary_mask, current_data, 'FilledArea');   %Figure out the filled areas
                
                if numel(current_areas) == 2 ;            %If fails criteria set to 0. If not, set to value.
                    current_block_area = current_areas(1).FilledArea;
                    current_post_area = current_areas(2).FilledArea;
                elseif numel(current_areas) < 2;
                    current_block_area = 3001;                                         %If multiple values become set
                    current_post_area = 3001;
                elseif numel(current_areas) > 2;
                    current_block_area = 1000;
                    current_post_area = 1000;
                end
                
                if current_block_area <= area_block_min && current_block_area >= area_block_min_edge; %Under minimum area, then decrease thresh
                    start_contrast_thresh = start_contrast_thresh - 500;
                    loop_thresh = 'y';
                    counter_breaker = counter_breaker + 1;
                end
                
                if current_block_area >= area_block_max && current_block_area <= area_block_max_edge; %Above, increase threshold 
                    start_contrast_thresh = start_contrast_thresh + 500;
                    loop_thresh = 'y';
                    counter_breaker = counter_breaker + 1;
                end
                
                if current_block_area > area_block_max_edge;
                    start_contrast_thresh = start_contrast_thresh + 1000;
                    loop_thresh = 'y';
                    counter_breaker = counter_breaker + 1;
                end
                
                if current_block_area < area_block_min_edge;
                    start_contrast_thresh = start_contrast_thresh - 1000;
                    loop_thresh = 'y';
                    counter_breaker = counter_breaker + 1;
                end
                
                if current_block_area < area_block_max && current_block_area > area_block_min;
                    loop_thresh = 'n';
                    counter_breaker = counter_breaker + 20;
                    disp('Found');
                end
                
                disp(current_block_area);
                
            end
            %loop_thresh = 'n';
        end
        datarack_contrast_thresh(counter_analysistime,1,counter_analysissensor) = start_contrast_thresh;
        disp(sprintf('Contrast Thresh %d',start_contrast_thresh));
        arearack(counter_analysistime,1,counter_analysissensor) = current_block_area;
        arearack(counter_analysistime,2,counter_analysissensor) = current_post_area;
        current_centroid = regionprops(binary_mask, current_data, 'WeightedCentroid' ); %First number is block centroid, second number is post centroid
        
        clear binary_mask start_contrast_thresh;
        
        if numel(current_centroid) > 2 || numel(current_centroid) < 2;      %These are going to be x-y coordinates
            temp_blocks = [0,0];
            temp_posts = [0,0];
        else
            temp_blocks = current_centroid(1).WeightedCentroid;
            temp_posts = current_centroid(2).WeightedCentroid;
        end
        datarack_blocks(counter_analysistime,1,counter_analysissensor) = temp_blocks(1,1);
        datarack_blocks(counter_analysistime,2,counter_analysissensor) = temp_blocks(1,2);
        datarack_posts(counter_analysistime,1,counter_analysissensor) = temp_posts(1,1);
        datarack_posts(counter_analysistime,2,counter_analysissensor) = temp_posts(1,2);
        
        counter_analysissensor = counter_analysissensor + 1;
    end
    counter_analysistime = counter_analysistime + 1;
    disp(counter_analysistime);
    waitbar((counter_analysistime-frame_start) / steps_threshholding);
end
close(h2);
toc;
%%
%Calculate background brightness using first 3 frames. 
datarack_brightness_reference = mean(datarack_brightness(frame_start:frame_start+2,1,:));
counter_area = 1;
while counter_area <= roi_n;
    datarack_brightness(:,1,counter_area) = (datarack_brightness(:,1,counter_area) - datarack_brightness_reference(counter_area))...
        /datarack_brightness_reference(counter_area)*100;
    counter_area = counter_area + 1;
end
datarack_brightness(1:frame_start,1,:)=0;                                   %This sets the starting frame as well as everything before it to zero
datarack_brightness_avg = mean(datarack_brightness,3);                      %defines mean brightness across sensors
area_5min = mean(datarack_brightness_avg(146:150));                         %defines mean area at around 5 minutes
%%
%Calculate the post to block distance
%k = 38;                                                                     %Default for soft posts (H = 25, D = 5.71,  E = 3.8)
k = 49.58;                                                                  %This is the default stiff post stiffness nN/um (H = 25 micron, D = 6.1, E = 3.8)
converter = 0.464;                                                          %Micron to pixel conversion, High Zoom: 0.301, Low Zoom 0.464
post_spacing = 9;                                                           %Micron distance between surfaces
force_Lbound = 0;                                                           %Lower Boundary of acceptable force (below 0 is no good)
force_Hbound = 0.5*post_spacing*k;                                          %Upper Boundary of acceptable force, taking into account the pilling effect (4.5 micron * k)

data_distance = zeros(numel(image_names_sorted),1,roi_n);                   %Allocate data_distance
force_pure = zeros(numel(image_names_sorted),1,roi_n);                      %Allocate force_pure
force_average = zeros(numel(image_names_sorted),1);                          %Allocate force_average

counter_distance_time = frame_start;

while counter_distance_time <= numel(image_names_sorted);
    counter_distance_roi = 1;
    while counter_distance_roi <= roi_n;
        temp_dist_stor(1,:) = datarack_blocks(counter_distance_time,:,counter_distance_roi);
        temp_dist_stor(2,:) = datarack_posts(counter_distance_time,:,counter_distance_roi);
        data_distance(counter_distance_time,:,counter_distance_roi) = ...
            sqrt((temp_dist_stor(2,1)-temp_dist_stor(1,1))^2+(temp_dist_stor(2,2)-temp_dist_stor(1,2))^2)*converter; %Calculate the actual forces here
        
        if data_distance(counter_distance_time,:,counter_distance_roi) == 0;
            data_distance(counter_distance_time,:,counter_distance_roi) = NaN;
        end
        
        force_pure(counter_distance_time,:,counter_distance_roi) = ...
            (data_distance(frame_start,:,counter_distance_roi)-...
            data_distance(counter_distance_time,:,counter_distance_roi))*k; %Multiply out forces
        
        if force_pure(counter_distance_time,:,counter_distance_roi) <= force_Lbound;   %Filter out force values lower than zero
            force_pure(counter_distance_time,:,counter_distance_roi) = NaN;
        end
        
        if force_pure(counter_distance_time,:,counter_distance_roi) >= force_Hbound;   %Set forces above the high bound to the high bound
            force_pure(counter_distance_time,:,counter_distance_roi) = force_Hbound;
        end
        
        clear temp_dist_stor;
        counter_distance_roi = counter_distance_roi + 1;
    end
    force_average(counter_distance_time) = nanmean2(force_pure(counter_distance_time,1,:));
    counter_distance_time = counter_distance_time + 1;
end
%%
%Multiply the observed distance by 2 as pill shape compensation
force_pure_correct = force_pure*2;
force_average_correct = force_average*2;
force_movavg = zeros(numel(image_names_sorted),1);

%Plot Everything & calculate the 10 second & 30 second moving averages
movavg_p_10 = 10;
movavg_p_30 = 30;
save_this = figure;

counter_plotter = 1;
while counter_plotter <= roi_n;
    plot(force_pure_correct(:,:,counter_plotter));
    hold on
    counter_plotter = counter_plotter+1;
end

force_movavg_s_10 = [1/(2*movavg_p_10);repmat(1/movavg_p_10,movavg_p_10-1,1);1/(2*movavg_p_10)]; %Computes Moving Averages 
force_movavg_s_30 = [1/(2*movavg_p_30);repmat(1/movavg_p_30,movavg_p_30-1,1);1/(2*movavg_p_30)];
force_movavg_10 = conv(force_average_correct,force_movavg_s_10);
force_movavg_30 = conv(force_average_correct,force_movavg_s_30);

% counter_movavg = 1;                                                            
% while counter_movavg >= numel(image_names_sorted);
%     force_movavg_10(counter_movavg,1) = force_movavg_10(counter_movavg,1);
%     force_movavg_30(counter_movavg,1) = force_movavg_30(counter_movavg,1);
%     counter_movavg = counter_movavg+1;
% end


counter_confidence = 1;                                                     %Computes Confidence Values & Lysis Values
while counter_confidence <= numel(image_names_sorted);
    confidence(counter_confidence,1) = sum(~isnan(force_pure_correct(counter_confidence,1,:)));
    confidence(counter_confidence,1) = confidence(counter_confidence) / roi_n;
    counter_confidence = counter_confidence+1;
end

%This section calculates the moving average of the confidence metric
%confidence_timescale_10 = 10; 
%confidence_timescale_30 = 30;
%confidence_s_10 = [1/(2*confidence_timescale_10);repmat(1/confidence_timescale_10,confidence_timescale_10-1,1);1/(2*confidence_timescale_10)]; %Computes Moving Averages 
%confidence_s_30 = [1/(2*confidence_timescale_30);repmat(1/confidence_timescale_30,confidence_timescale_30-1,1);1/(2*confidence_timescale_30)]; %Computes Moving Averages
%confidence_10 = conv(confidence,confidence_s_10);
%confidence_30 = conv(confidence,confidence_s_30);
confidence_5min = mean(confidence(frame_start:150));                      %Confidence output is the average of the confidence number up to 5 minutes
confidence_1min = mean(confidence(frame_start:30+frame_start));                       %Used for calculating Lysis Shedding Parameter
confidence_lysis = mean(confidence(140:150));       %Lysis confidence is the average from 5 minutes to the end
confidence_lysis_dropout = (confidence_1min - confidence_lysis);        %Lysis dropout is the change in confidence from 1 minutes to end-point

plot_x_end = numel(image_names_sorted);
axis([0 plot_x_end -20 450]);
hold on
hline1 = plot(force_average_correct,'.b');
hline2 = plot(force_movavg_10,'.r');
hline3 = plot(force_movavg_30,'.g');
xlabel('Frame Number');
ylabel('Force (nN)');
title('nN on Post');
legend([hline1 hline2 hline3],'MA1','MA10','MA30');

%Figure out the values of onset, X min force, max force, and lysis

%Onset: defined by the average of the time index for the first 5 times above 50nN in the 10 sec moving average
%This gets around cases where, if using consecutive 5 frame criteria,
%forces dropping out and beating definition
onset = find(force_movavg_10 > 50, 5, 'first');                             %Criteria is >50nN for 5 consecutive frames
onset = mean(onset);
text(10,380,sprintf('Onset: %d frames',onset));

%X minute force: defined as the force at X time, default 5 min
x_time = 5*60/2;
force_x_time = force_movavg_10(x_time);
text(10,360,sprintf('5-min F: %f nN',force_x_time));
text(10,340,sprintf('1-min Conf: %f',confidence_1min));

%max force: defined by the maximum value of the moving average
force_max = max(force_movavg_10);
force_max_time = find(force_movavg_10 >= max(force_max),1,'first');
text(10,320,sprintf('Max t: %d frame',force_max_time));
text(10,300,sprintf('Max F: %f nN',force_max));

%Lysis: defined by the drop at a user defined time to another user defined time, default 5min and 10min
time_lysis_start = force_max_time;
time_lysis_end = numel(force_average);
lysis_percent = ceil((force_movavg_10(time_lysis_start)-force_movavg_10(time_lysis_end))...
    /force_movavg_10(time_lysis_start)*100);
text(120,380,sprintf('Lysis: %d',lysis_percent));
text(120,360,sprintf('Lys Conf: %f',confidence_lysis));
text(120,340,sprintf('Shed Conf: %f',confidence_lysis_dropout));

%Second Figure for Area
save_this2 = figure;

counter_plotter2 = 1;
while counter_plotter2 <= roi_n;
    plot(datarack_brightness(:,:,counter_plotter2));
    hold on
    counter_plotter2 = counter_plotter2+1;
end

axis([0 plot_x_end -5 50]);
hold on
hline4 = plot(datarack_brightness_avg,'.r');
xlabel('Frame Number');
ylabel('3-frame ref. normalized brightness (% increase)');
title('Brightness vs. Frame');
legend([hline4],'Adjusted Average');


%Format everything into a data output structure
data_out = struct('frame_start', frame_start, 'onset', onset, 'force', force_x_time, 'max_t', ...
    force_max_time, 'max_f', force_max, 'lysis', lysis_percent, 'confidence_5min', ...
    confidence_5min , 'confidence_1min', confidence_1min, 'confidence_lysis' ,... 
    confidence_lysis , 'confidence_lysis_dropout', confidence_lysis_dropout, ...
    'area_5min', area_5min);

%Read in the Patient ID
[num txt raw] = xlsread(fullfile(experiment_directory,'Patient ID.xls'),1,'A1');
PatientIdentifier = raw; 

%Save everything out
saveas(save_this,fullfile(experiment_directory,'PrototypeImageAnalyzer_v3 nN vs Frame'), 'png');
saveas(save_this2,fullfile(experiment_directory,'PrototypeImageAnalyzer_v3 Bright vs Frame'), 'png'); 

export_path = fullfile(experiment_directory,sprintf('%s.xlsx',PatientIdentifier{1,1}));

xlswrite(export_path,force_average_correct,'1 Average Forces','A1');
xlswrite(export_path,force_movavg_10,'10 Moving Average','A1');
xlswrite(export_path,force_movavg_30,'30 Moving Average','A1');
xlswrite(export_path,confidence,'Post Confidence','A1');
xlswrite(export_path,datarack_brightness_avg,'Area via Bright','A1');
xlswrite(export_path, ...
    {'Patient ID', PatientIdentifier{1,1} ; 'Frame Start', frame_start ; ...
    'Starting Threshold', contrast_thresh_value ; ...
    'Onset [MA10,5consecutive]>=50nN (frames)', data_out.onset ; ...
    'Force@5min (nN)', data_out.force ; 'MaxF@Any (nN)', data_out.max_f ;...
    'Time@MaxForce (s)', data_out.max_t ; 'Lysis (%)', data_out.lysis ; ...
     '1 min Conf', data_out.confidence_1min ; 'Lysis Conf', data_out.confidence_lysis ; ...
     'Shed Conf', data_out.confidence_lysis_dropout ; 'Area @ 5 min' , data_out.area_5min}, 'Data Out', 'A1');

disp('Post Stiffness is:');
disp(k);
disp('Force Analysis Complete. Files are written to the experiment folder.');